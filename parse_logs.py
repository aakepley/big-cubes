import gzip
from datetime import datetime
import os
import sys
import re
import numpy as np
import ipdb



def parse_pipe_casalog(logfile):
    '''
    Purpose: parse one casa log generated by the pipeline

    Notes:

    If I really wanted to get fancy, I could do the stats per stage.
         -- The pipeline marks each stage with the message: "Starting execution for stage 27", etc.
                so I can at least break at stage boundaries.
         -- On the next line they have:    Equivalent CASA call: hif_makeimages(pipelinemode="automatic").
                With this information I could even name the stages.


    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/17/2023   A.A. Kepley     Original Code

    '''

    pipelineStartRE = re.compile(r"Starting procedure execution")
    pipelineEndRE = re.compile(r"Saving final weblog")
    
    # key off of task time report right before End Task message in CASA
    taskTimeRE = re.compile(r"Task (?P<taskname>\w+) complete. Start time: (?P<startTime>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{6}) End time: (?P<endTime>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{6})" )

    # MPI server
    mpiRE = re.compile(r"MPIServer-")

    # plotms Tier0
    plotmsTier0RE = re.compile(r"Compressed \d+ plotms jobs to \d+ jobs")
    
    # tclean Tier0
    tcleanTier0RE = re.compile(r"setupCluster, Setting up \d+ engines")

    # uvcontfit
    uvcontfitStartRE = re.compile(r"Executing uvcontfit")
    uvcontfitEndRE = re.compile(r"Executing command \.\.\.hif_uvcontsub")
    
    # tool time call
    toolTimeRE = re.compile(r"(?P<toolname>\w+\.\w+\.\w+)\(.*?\) CASA tool call took (?P<tooltime>.*?)s")

    # ia.getprofile in fincont
    iagetprofileStartRE = re.compile(r"Running ia.getprofile")
    
    # date format
    dateFmtRE = re.compile(r"(?P<timedate>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})")

    # open file
    if logfile.endswith('.gz'):
        filein = gzip.open(logfile,mode='rb')
    else:
        filein = open(logfile, 'rb')

    # initialize values
    results = {}
    startTime = 0
    endTime = 0
    mpiresults = {}

    pipeStartTimeStr = ''
    
    # parse log
    for line in filein:

        line = line.decode('utf-8')

        ## Pipeline start  -- only take first value
        if (pipelineStartRE.search(line)) and (not bool(pipeStartTimeStr)):
            pipeStartTimeStr = dateFmtRE.search(line).group('timedate')
            pipeStartTime = datetime.strptime(pipeStartTimeStr,'%Y-%m-%d %H:%M:%S')

        ## Pipeline end
        if pipelineEndRE.search(line):
            pipeEndTimeStr = dateFmtRE.search(line).group('timedate')
            pipeEndTime = datetime.strptime(pipeEndTimeStr,'%Y-%m-%d %H:%M:%S')
        
        ## figure out if we are starting tier0 parallelization
        if (plotmsTier0RE.search(line) or tcleanTier0RE.search(line)):

            # save results so far
            for mykey in mpiresults.keys():
                timeDiff = mpiresults[mykey]['endTime'] - mpiresults[mykey]['startTime']
                timeDiff = timeDiff.total_seconds()        

                # indicate if mpi
                if mykey+'_mpi' in results.keys():
                    results[mykey+'_mpi'] = results[mykey+'_mpi'] + timeDiff
                else:
                    results[mykey+'_mpi'] = timeDiff

                # add to total
                if mykey in results.keys():
                    results[mykey] = results[mykey] + timeDiff
                else:
                    results[mykey] = timeDiff
            
            # reset mpiresults
            mpiresults = {}

        ## look for uvcontfit
        if uvcontfitStartRE.search(line):
            uvcontfitStartTimeStr = dateFmtRE.search(line).group('timedate')
            uvcontfitStartTime = datetime.strptime(uvcontfitStartTimeStr,'%Y-%m-%d %H:%M:%S')

        if uvcontfitEndRE.search(line):
            uvcontfitEndTimeStr = dateFmtRE.search(line).group('timedate')
            uvcontfitEndTime = datetime.strptime(uvcontfitEndTimeStr,'%Y-%m-%d %H:%M:%S')

            timeDiff = (uvcontfitEndTime - uvcontfitStartTime).total_seconds()

            # add to uvcontfit total
            if 'uvcontfit' in results.keys():
                results['uvcontfit'] = timeDiff  + results['uvcontfit']
            else:
                results['uvcontfit'] = timeDiff
        
            # add to casa tasks total
            if 'casatasks' in results.keys():
                results['casatasks'] = results['casatasks'] + timeDiff
            else:
                results['casatasks' ] = timeDiff
            
                
        ## look for iagetprofile
        if iagetprofileStartRE.search(line):
            iagetprofileStartTimeStr = dateFmtRE.search(line).group('timedate')
            iagetprofileStartTime = datetime.strptime(iagetprofileStartTimeStr,'%Y-%m-%d %H:%M:%S')
            
            # read in intermediate line
            line = filein.readline().decode('utf-8')

            # read in third line that gives end.
            line = filein.readline().decode('utf-8')
            iagetprofileEndTimeStr = dateFmtRE.search(line).group('timedate')
            iagetprofileEndTime = datetime.strptime(iagetprofileEndTimeStr,'%Y-%m-%d %H:%M:%S')

            timeDiff =  (iagetprofileEndTime - iagetprofileStartTime).total_seconds()

            # add to ia.getprofile in results
            if 'ia.getprofile' in results.keys():
                results['ia.getprofile'] = timeDiff + results['ia.getprofile']
            else:
                results['ia.getprofile'] = timeDiff

            # add to total for casa tools
            if 'casatools' in results.keys():
                results['casatools'] = timeDiff + results['casatools']
            else:
                results['casatools'] = timeDiff
            
            
        # is it a task?
        if taskTimeRE.search(line):

            (taskStr,startTimeStr, endTimeStr) = taskTimeRE.search(line).groups()

            startTime = datetime.strptime(startTimeStr,  '%Y-%m-%d %H:%M:%S.%f')
            endTime = datetime.strptime(endTimeStr,  '%Y-%m-%d %H:%M:%S.%f')

            timeDiff = endTime - startTime
            timeDiff = timeDiff.total_seconds()                

            # separate out the pipeline parallelized imaging case.
            if mpiRE.search(line):
                
                if (taskStr in mpiresults.keys()):
                    # the start time should be the earliest time
                    newStartTime = min(mpiresults[taskStr]['startTime'],startTime)
                    mpiresults[taskStr]['startTime'] = newStartTime

                    # the end time should be the latest time
                    newEndTime = max(mpiresults[taskStr]['endTime'],endTime)
                    mpiresults[taskStr]['endTime'] = newEndTime

                else:
                    mpiresults[taskStr] = {}
                    mpiresults[taskStr]['startTime'] = startTime
                    mpiresults[taskStr]['endTime'] = endTime

            # non-pipeline parallelized
            else:
            
                # count up time spent on casatasks
                if 'casatasks' in results.keys():
                    results['casatasks'] = timeDiff + results['casatasks']
                else:
                    results['casatasks'] = timeDiff

                # count up time spent on individual casa tasks
                if taskStr in results.keys():
                    results[taskStr] = timeDiff + results[taskStr]
                else:
                    results[taskStr] = timeDiff
                
        # is it a tool?
        elif toolTimeRE.search(line):
            
            toolTime = float(toolTimeRE.search(line).group('tooltime'))
            toolName = toolTimeRE.search(line).group('toolname')

            # count up all time spent on casa tool calls
            if 'casatools' in results.keys():
                results['casatools'] = toolTime + results['casatools']
            else:
                results['casatools'] = toolTime

            # count up time spent on particular casa tool calls
            if toolName in results.keys():
                results[toolName] = toolTime + results[toolName]
            else:
                results[toolName] = toolTime

        else:
            continue



        
    # put any remainig mpi results in library.
    for mykey in mpiresults.keys():
        timeDiff = mpiresults[mykey]['endTime'] - mpiresults[mykey]['startTime']
        timeDiff = timeDiff.total_seconds()        

        if mykey+'_mpi' in results.keys():
            results[mykey+'_mpi'] = results[mykey+'_mpi'] + timeDiff

        else:
            results[mykey+'_mpi'] = timeDiff

        # add to total
        if mykey in results.keys():
            results[mykey] = results[mykey] + timeDiff
        else:
            results[mykey] = timeDiff

    # calculate total time spent on pipeline
    results['pipetime'] = (pipeEndTime - pipeStartTime).total_seconds()

    # close input log
    filein.close()

    # return results.
    return results
                                                        

def parse_all_pipe_casalogs(logdir,n=-1):
    '''
    Purpose: parse all weblogs in directory

    Notes:
    -- May want to add a testing parameter to just do first n. Or restart based on pickled results?

    Date        Programmer      Description of changes
    ----------------------------------------------------------------------
    1/17/2023   A.A. Kepley     Original Code
    '''

    import glob
    from large_cubes import under_to_slash

    allresults = {}
    
    if os.path.exists(logdir):
    
        loglist = glob.glob(os.path.join(logdir,"member.*calimage*weblog.tgz","casa*.log*"))[0:n]

        for mylog in loglist:

            name = mylog.split('/')[-2]
            mous = name.split('.')[1]
            mous = under_to_slash(mous)

            print("processing casa log for mous "+mous)
            results = parse_pipe_casalog(mylog)
            
            allresults[mous] = results

    return allresults

    

    

    

  
