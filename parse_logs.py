import os
import sys
import numpy as np
import matplotlib.pyplot as plt
from astropy.table import Table
import ipdb



def parse_pipe_casalog(logfile):

    '''
    Purpose: parse one casa log generated by the pipeline

    Notes:

    If I really wanted to get fancy, I could do the stats per stage.
         -- The pipeline marks each stage with the message: "Starting execution for stage 27", etc.
                so I can at least break at stage boundaries.
         -- On the next line they have:    Equivalent CASA call: hif_makeimages(pipelinemode="automatic").
                With this information I could even name the stages.

    So casa will spit out times of the format 2019-12-05 24:00:00,
    which python really hates. This isn't a common issue, so I think
    I'm going to ignore? 

    Potential solution:
    -- split on space.
    -- if 2nd half is 24:00:00
    --- then change to 23:59:00
    -- join string
    -- do datetime parsing.
    -- But it would require a bunch of changes to the code and I'm short on time. Could make function.
    
    -- I could also just go through and manually fix the logs. Not great.


    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/17/2023   A.A. Kepley     Original Code

    '''
    import gzip
    from datetime import datetime
    import re
    
    casaVersionRE = re.compile(r"CASA Version (?P<casaversion>.*)")

    recipeRE = re.compile(r"Procedure name: (?P<recipename>\w+)")

    pipelineStartRE = re.compile(r"Starting procedure execution")
    pipelineEndRE = re.compile(r"Saving final weblog")

    # key off of task time report right before End Task message in CASA
    ## But this doesn't work in CASA 5.6.1
    taskTimeRE = re.compile(r"Task (?P<taskname>\w+) complete. Start time: (?P<startTime>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{6}) End time: (?P<endTime>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{6})" )

    # these will work for 5.6.1
    beginTaskRE = re.compile(r'Begin Task: (?P<taskname>\w+)')
    endTaskRE = re.compile(r'End Task: (?P<taskname>\w+)')

    # MPI server
    mpiRE = re.compile(r"MPIServer-")

    # plotms Tier0
    plotmsTier0RE = re.compile(r"Compressed \d+ plotms jobs to \d+ jobs")
    
    # tclean Tier0
    tcleanTier0RE = re.compile(r"setupCluster, Setting up \d+ engines")
    #tcleanTier0RE = re.compile(r"Executing Tier0PipelineTask") # will this work for both??NO
    tcleanTier0_casa56RE = re.compile(r'Starting execution for stage 19')
    # uvcontfit
    uvcontfitStartRE = re.compile(r"Executing uvcontfit")
    uvcontfitEndRE = re.compile(r"Executing command \.\.\.hif_uvcontsub")
    
    # tool time call
    toolTimeRE = re.compile(r"(?P<toolname>\S+)\(.*?\) CASA tool call took (?P<tooltime>.*?)s")

    # ia.getprofile in fincont
    iagetprofileStartRE = re.compile(r"Running ia.getprofile")
    
    # date format
    dateFmtRE = re.compile(r"(?P<timedate>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})")

    # open file
    if logfile.endswith('.gz'):
        filein = gzip.open(logfile,mode='rb')
    else:
        filein = open(logfile, 'rb')

    # initialize values
    results = {}
    startTime = 0
    endTime = 0
    mpiresults = {}
    tmpresults = {}

    # parse log
    for line in filein:

        line = line.decode('utf-8')

        ## casa version
        if 'casaversion' not in results.keys():
            if casaVersionRE.search(line):
                results['casaversion'] = casaVersionRE.search(line).group('casaversion')
                results['casaversion'] = results['casaversion'].replace('PIPELINE','').strip()


        ## recipe
        if 'recipe' not in results.keys():
            if recipeRE.search(line):
                results['recipe'] = recipeRE.search(line).group('recipename')

        ## Pipeline start  -- only take first value
        if 'pipeStartTime' not in results.keys():
            if pipelineStartRE.search(line):
                pipeStartTimeStr = dateFmtRE.search(line).group('timedate')
                results['pipeStartTime'] = datetime.strptime(pipeStartTimeStr,'%Y-%m-%d %H:%M:%S')

        ## Pipeline end
        if pipelineEndRE.search(line):
            pipeEndTimeStr = dateFmtRE.search(line).group('timedate')
          
            results['pipeEndTime'] = datetime.strptime(pipeEndTimeStr,'%Y-%m-%d %H:%M:%S')      


        
        ## figure out if we are starting tier0 parallelization
        if (plotmsTier0RE.search(line) or tcleanTier0RE.search(line) or tcleanTier0_casa56RE.search(line)):

            # save results so far
            for mykey in mpiresults.keys():
                timeDiff = mpiresults[mykey]['endTime'] - mpiresults[mykey]['startTime']
                timeDiff = timeDiff.total_seconds()        

                # indicate if mpi
                if mykey+'_mpi' in results.keys():
                    results[mykey+'_mpi'] = results[mykey+'_mpi'] + timeDiff
                else:
                    results[mykey+'_mpi'] = timeDiff
                    
                # add to total
                if mykey in results.keys():
                    results[mykey] = results[mykey] + timeDiff
                else:
                    results[mykey] = timeDiff
            
            # reset mpiresults
            mpiresults = {}


        ## look for uvcontfit
        if uvcontfitStartRE.search(line):
            uvcontfitStartTimeStr = dateFmtRE.search(line).group('timedate')
            uvcontfitStartTime = datetime.strptime(uvcontfitStartTimeStr,'%Y-%m-%d %H:%M:%S')

        if uvcontfitEndRE.search(line):
            uvcontfitEndTimeStr = dateFmtRE.search(line).group('timedate')
            uvcontfitEndTime = datetime.strptime(uvcontfitEndTimeStr,'%Y-%m-%d %H:%M:%S')

            timeDiff = (uvcontfitEndTime - uvcontfitStartTime).total_seconds()

            # add to uvcontfit total
            if 'uvcontfit' in results.keys():
                results['uvcontfit'] = timeDiff  + results['uvcontfit']
            else:
                results['uvcontfit'] = timeDiff
        
            # add to casa tasks total
            if 'casatasks' in results.keys():
                results['casatasks'] = results['casatasks'] + timeDiff
            else:
                results['casatasks' ] = timeDiff
            
                
        ## look for iagetprofile
        if iagetprofileStartRE.search(line):
            iagetprofileStartTimeStr = dateFmtRE.search(line).group('timedate')
            iagetprofileStartTime = datetime.strptime(iagetprofileStartTimeStr,'%Y-%m-%d %H:%M:%S')
            
            # read in intermediate line
            line = filein.readline().decode('utf-8')

            # read in third line that gives end.
            line = filein.readline().decode('utf-8')
            iagetprofileEndTimeStr = dateFmtRE.search(line).group('timedate')
            iagetprofileEndTime = datetime.strptime(iagetprofileEndTimeStr,'%Y-%m-%d %H:%M:%S')

            timeDiff =  (iagetprofileEndTime - iagetprofileStartTime).total_seconds()

            # add to ia.getprofile in results
            if 'ia.getprofile' in results.keys():
                results['ia.getprofile'] = timeDiff + results['ia.getprofile']
            else:
                results['ia.getprofile'] = timeDiff

            # add to total for casa tools
            if 'casatools' in results.keys():
                results['casatools'] = timeDiff + results['casatools']
            else:
                results['casatools'] = timeDiff
            
        # process tasks        
        if 'casaversion' in results.keys():
            # process tasks without info line
            if results['casaversion'] == '5.6.1-8':            
                if beginTaskRE.search(line):
                    taskStr = beginTaskRE.search(line).group('taskname')
                    startTimeStr = dateFmtRE.search(line).group('timedate')

                    startTime = datetime.strptime(startTimeStr, '%Y-%m-%d %H:%M:%S')
                    
                    if mpiRE.search(line):
                        if taskStr in mpiresults.keys():
                            newStartTime = min(mpiresults[taskStr]['startTime'],startTime)
                            mpiresults[taskStr]['startTime'] = newStartTime
                        else:
                            mpiresults[taskStr] = {}
                            mpiresults[taskStr]['startTime'] = startTime
                    else:
                        tmpresults[taskStr] = {}
                        tmpresults[taskStr]['startTime'] = startTime
                        
                
                if endTaskRE.search(line):
                    taskStr = endTaskRE.search(line).group('taskname')
                    endTimeStr = dateFmtRE.search(line).group('timedate')

                    endTime = datetime.strptime(endTimeStr, '%Y-%m-%d %H:%M:%S')

                    # if mpi find max time.
                    if mpiRE.search(line):
                        if taskStr in mpiresults.keys():
                            if 'endTime' in mpiresults[taskStr].keys():
                                newEndTime = max(mpiresults[taskStr]['endTime'],endTime)
                                mpiresults[taskStr]['endTime'] = newEndTime
                            else:
                                mpiresults[taskStr]['endTime'] = endTime
                        else:
                            print("Start time but no end time. shouldn't happen")

                    # other wise take the difference and save.
                    else:
                        tmpresults[taskStr]['endTime'] = endTime

                        timeDiff = tmpresults[taskStr]['endTime'] - tmpresults[taskStr]['startTime']
                        timeDiff = timeDiff.total_seconds()

                        if 'casatasks' in results.keys():
                            results['casatasks'] = timeDiff + results['casatasks']
                        else:
                            results['casatasks'] = timeDiff

                        if taskStr in results.keys():
                            results[taskStr] = timeDiff + results[taskStr]
                        else:
                            results[taskStr] = timeDiff
                        
                        # clear tmp results.
                        tmpresults = {}
                    
            else: 
                # process tasks with info line
                if taskTimeRE.search(line):

                    (taskStr,startTimeStr, endTimeStr) = taskTimeRE.search(line).groups()

                    startTime = datetime.strptime(startTimeStr,  '%Y-%m-%d %H:%M:%S.%f')
                    endTime = datetime.strptime(endTimeStr,  '%Y-%m-%d %H:%M:%S.%f')

                    # separate out the pipeline parallelized imaging case.
                    if mpiRE.search(line):
                
                        if (taskStr in mpiresults.keys()):
                            # the start time should be the earliest time
                            newStartTime = min(mpiresults[taskStr]['startTime'],startTime)
                            mpiresults[taskStr]['startTime'] = newStartTime

                            # the end time should be the latest time
                            newEndTime = max(mpiresults[taskStr]['endTime'],endTime)
                            mpiresults[taskStr]['endTime'] = newEndTime

                        else:
                            mpiresults[taskStr] = {}
                            mpiresults[taskStr]['startTime'] = startTime
                            mpiresults[taskStr]['endTime'] = endTime

                    # non-pipeline parallelized
                    else:

                        timeDiff = endTime - startTime
                        timeDiff = timeDiff.total_seconds()     
            
                        # count up time spent on casatasks
                        if 'casatasks' in results.keys():
                            results['casatasks'] = timeDiff + results['casatasks']
                        else:
                            results['casatasks'] = timeDiff

                        # count up time spent on individual casa tasks
                        if taskStr in results.keys():
                            results[taskStr] = timeDiff + results[taskStr]
                        else:
                            results[taskStr] = timeDiff

        # is it a tool?
        if toolTimeRE.search(line):
            
            toolTime = float(toolTimeRE.search(line).group('tooltime'))
            toolName = toolTimeRE.search(line).group('toolname')

            # unify tool names between 5.6.1 and 6.x series.
            toolName = toolName.replace('casatools.','')

            # count up all time spent on casa tool calls
            if 'casatools' in results.keys():
                results['casatools'] = toolTime + results['casatools']
            else:
                results['casatools'] = toolTime

            # count up time spent on particular casa tool calls
            if toolName in results.keys():
                results[toolName] = toolTime + results[toolName]
            else:
                results[toolName] = toolTime
    
        
    # put any remaining mpi results in library.
    for mykey in mpiresults.keys():
        timeDiff = mpiresults[mykey]['endTime'] - mpiresults[mykey]['startTime']
        timeDiff = timeDiff.total_seconds()        

        if mykey+'_mpi' in results.keys():
            results[mykey+'_mpi'] = results[mykey+'_mpi'] + timeDiff

        else:
            results[mykey+'_mpi'] = timeDiff

        # add to total
        if mykey in results.keys():
            results[mykey] = results[mykey] + timeDiff
        else:
            results[mykey] = timeDiff

    # calculate total time spent on pipeline
    if ('pipeEndTime' in results.keys()) and ('pipeStartTime' in results.keys()):
        results['pipetime'] = (results['pipeEndTime'] - results['pipeStartTime']).total_seconds()
    else:
        print("Mous is malformed setting results to empty.")
        results = {} # set results to empty to indicate malformed mous

    # close input log
    filein.close()

    # return results.
    return results
                                                        

def parse_all_pipe_casalogs(logdir,n=-1,recipe='hifa_calimage*',
                            errfile='mous_err.txt'):
    '''
    Purpose: parse all weblogs in directory


    TO DO: 
    -- add a parameter to look for a particular recipe

    Date        Programmer      Description of changes
    ----------------------------------------------------------------------
    1/17/2023   A.A. Kepley     Original Code
    '''

    import glob
    from large_cubes import under_to_slash

    ferr = open(errfile,'w')

    allresults = {}
    
    if os.path.exists(logdir):
    
        loglist = glob.glob(os.path.join(logdir,"member.*."+recipe+".weblog.tgz","casa*.log*"))[0:n]

        for mylog in loglist:

            name = mylog.split('/')[-2]
            mous = name.split('.')[1]
            mous = under_to_slash(mous)

            try:
                print("processing casa log for mous "+mous)
                results = parse_pipe_casalog(mylog)
                allresults[mous] = results

            except:
                print('*** Bad things have happened here: '+ mous)
                ferr.write(mous+'\n')

    ferr.close()

    return allresults

        
def convert_to_astropy(pkl_file, dump_rows=None):
    '''
    Purpose: convert casa/pl timing pickle to astropy table

    pkl: input pickle
    
    Date        Programmer      Description of Changes
    ----------------------------------------------------
    1/30/2023   A.A. Kepley     Original Code
  
    '''
    import pickle
    import pandas as pd
    from large_cubes import fix_mous_col

    pkl = pickle.load(open(pkl_file,'rb'))

    rpd = pd.DataFrame(pkl).transpose()

    # fix up data types
    mycols_float = ['importasdm','flagdata','listobs','plotms','clearstat',
                    'flagcmd','gencal','plotbandpass','wvrgcal','gaincal',
                    'bandpass','setjy','flagmanager','applycal','fluxscale',
                    'tclean','exportfits','mstransform','imhead','immoments',
                    'imstat','imsubimage','makemask','immath','uvcontfit','visstat',
                    'pipetime','casatasks','casatools','imager.selectvis','imager.advise',
                    'imager.apparentsens','ia.getprofile']
    
    mycols_dtype = {}
    for col in mycols_float:
        mycols_dtype[col]  = 'float'

    mycols = ['casaversion','recipe']
    for col in mycols:
        mycols_dtype[col] = 'str'
        
    rpd = rpd.astype(dtype=mycols_dtype)

    mytab = Table.from_pandas(rpd,index=True)
    mytab.rename_column('index','mous')
    mytab = Table(mytab,masked=True)

    for col in mytab.columns:
        if col in mycols_float:
            mytab.fill_value = np.nan

    fix_mous_col(mytab)

    if dump_rows:
        for myrow in dump_rows:
            idx = mytab['mous'] == myrow
            mytab = mytab[~idx]
            
    
    return mytab


