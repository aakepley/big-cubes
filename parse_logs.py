import os
import sys
import numpy as np
import matplotlib.pyplot as plt
from astropy.table import Table
import ipdb



def parse_pipe_casalog(logfile):
    '''
    Purpose: parse one casa log generated by the pipeline

    Notes:

    If I really wanted to get fancy, I could do the stats per stage.
         -- The pipeline marks each stage with the message: "Starting execution for stage 27", etc.
                so I can at least break at stage boundaries.
         -- On the next line they have:    Equivalent CASA call: hif_makeimages(pipelinemode="automatic").
                With this information I could even name the stages.


    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/17/2023   A.A. Kepley     Original Code

    '''
    import gzip
    from datetime import datetime
    import re
    
    casaVersionRE = re.compile(r"CASA Version (?P<casaversion>.*)")

    recipeRE = re.compile(r"Procedure name: (?P<recipename>\w+)")

    pipelineStartRE = re.compile(r"Starting procedure execution")
    pipelineEndRE = re.compile(r"Saving final weblog")

    # key off of task time report right before End Task message in CASA
    ## But this doesn't work in CASA 5.6.1
    taskTimeRE = re.compile(r"Task (?P<taskname>\w+) complete. Start time: (?P<startTime>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{6}) End time: (?P<endTime>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{6})" )

    # these will work for 5.6.1
    beginTaskRE = re.compile(r'Begin Task: (?P<taskname>\w+)')
    endTaskRE = re.compile(r'End Task: (?P<taskname>\w+)')

    # MPI server
    mpiRE = re.compile(r"MPIServer-")

    # plotms Tier0
    plotmsTier0RE = re.compile(r"Compressed \d+ plotms jobs to \d+ jobs")
    
    # tclean Tier0
    tcleanTier0RE = re.compile(r"setupCluster, Setting up \d+ engines")
    #tcleanTier0RE = re.compile(r"Executing Tier0PipelineTask") # will this work for both??NO
    tcleanTier0_casa56RE = re.compile(r'Starting execution for stage 19')
    # uvcontfit
    uvcontfitStartRE = re.compile(r"Executing uvcontfit")
    uvcontfitEndRE = re.compile(r"Executing command \.\.\.hif_uvcontsub")
    
    # tool time call
    toolTimeRE = re.compile(r"(?P<toolname>\S+)\(.*?\) CASA tool call took (?P<tooltime>.*?)s")

    # ia.getprofile in fincont
    iagetprofileStartRE = re.compile(r"Running ia.getprofile")
    
    # date format
    dateFmtRE = re.compile(r"(?P<timedate>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})")

    # open file
    if logfile.endswith('.gz'):
        filein = gzip.open(logfile,mode='rb')
    else:
        filein = open(logfile, 'rb')

    # initialize values
    results = {}
    startTime = 0
    endTime = 0
    mpiresults = {}
    tmpresults = {}

    # parse log
    for line in filein:

        line = line.decode('utf-8')

        ## casa version
        if 'casaversion' not in results.keys():
            if casaVersionRE.search(line):
                results['casaversion'] = casaVersionRE.search(line).group('casaversion')
                results['casaversion'] = results['casaversion'].replace('PIPELINE','').strip()


        ## recipe
        if 'recipe' not in results.keys():
            if recipeRE.search(line):
                results['recipe'] = recipeRE.search(line).group('recipename')

        ## Pipeline start  -- only take first value
        if 'pipeStartTime' not in results.keys():
            if pipelineStartRE.search(line):
                pipeStartTimeStr = dateFmtRE.search(line).group('timedate')
                results['pipeStartTime'] = datetime.strptime(pipeStartTimeStr,'%Y-%m-%d %H:%M:%S')

        ## Pipeline end
        if pipelineEndRE.search(line):
            pipeEndTimeStr = dateFmtRE.search(line).group('timedate')
            results['pipeEndTime'] = datetime.strptime(pipeEndTimeStr,'%Y-%m-%d %H:%M:%S')
        
        ## figure out if we are starting tier0 parallelization
        if (plotmsTier0RE.search(line) or tcleanTier0RE.search(line) or tcleanTier0_casa56RE.search(line)):

            # save results so far
            for mykey in mpiresults.keys():
                timeDiff = mpiresults[mykey]['endTime'] - mpiresults[mykey]['startTime']
                timeDiff = timeDiff.total_seconds()        

                # indicate if mpi
                if mykey+'_mpi' in results.keys():
                    results[mykey+'_mpi'] = results[mykey+'_mpi'] + timeDiff
                else:
                    results[mykey+'_mpi'] = timeDiff
                    
                # add to total
                if mykey in results.keys():
                    results[mykey] = results[mykey] + timeDiff
                else:
                    results[mykey] = timeDiff
            
            # reset mpiresults
            mpiresults = {}


        ## look for uvcontfit
        if uvcontfitStartRE.search(line):
            uvcontfitStartTimeStr = dateFmtRE.search(line).group('timedate')
            uvcontfitStartTime = datetime.strptime(uvcontfitStartTimeStr,'%Y-%m-%d %H:%M:%S')

        if uvcontfitEndRE.search(line):
            uvcontfitEndTimeStr = dateFmtRE.search(line).group('timedate')
            uvcontfitEndTime = datetime.strptime(uvcontfitEndTimeStr,'%Y-%m-%d %H:%M:%S')

            timeDiff = (uvcontfitEndTime - uvcontfitStartTime).total_seconds()

            # add to uvcontfit total
            if 'uvcontfit' in results.keys():
                results['uvcontfit'] = timeDiff  + results['uvcontfit']
            else:
                results['uvcontfit'] = timeDiff
        
            # add to casa tasks total
            if 'casatasks' in results.keys():
                results['casatasks'] = results['casatasks'] + timeDiff
            else:
                results['casatasks' ] = timeDiff
            
                
        ## look for iagetprofile
        if iagetprofileStartRE.search(line):
            iagetprofileStartTimeStr = dateFmtRE.search(line).group('timedate')
            iagetprofileStartTime = datetime.strptime(iagetprofileStartTimeStr,'%Y-%m-%d %H:%M:%S')
            
            # read in intermediate line
            line = filein.readline().decode('utf-8')

            # read in third line that gives end.
            line = filein.readline().decode('utf-8')
            iagetprofileEndTimeStr = dateFmtRE.search(line).group('timedate')
            iagetprofileEndTime = datetime.strptime(iagetprofileEndTimeStr,'%Y-%m-%d %H:%M:%S')

            timeDiff =  (iagetprofileEndTime - iagetprofileStartTime).total_seconds()

            # add to ia.getprofile in results
            if 'ia.getprofile' in results.keys():
                results['ia.getprofile'] = timeDiff + results['ia.getprofile']
            else:
                results['ia.getprofile'] = timeDiff

            # add to total for casa tools
            if 'casatools' in results.keys():
                results['casatools'] = timeDiff + results['casatools']
            else:
                results['casatools'] = timeDiff
            
        # process tasks        
        if 'casaversion' in results.keys():
            # process tasks without info line
            if results['casaversion'] == '5.6.1-8':            
                if beginTaskRE.search(line):
                    taskStr = beginTaskRE.search(line).group('taskname')
                    startTimeStr = dateFmtRE.search(line).group('timedate')

                    startTime = datetime.strptime(startTimeStr, '%Y-%m-%d %H:%M:%S')
                    
                    if mpiRE.search(line):
                        if taskStr in mpiresults.keys():
                            newStartTime = min(mpiresults[taskStr]['startTime'],startTime)
                            mpiresults[taskStr]['startTime'] = newStartTime
                        else:
                            mpiresults[taskStr] = {}
                            mpiresults[taskStr]['startTime'] = startTime
                    else:
                        tmpresults[taskStr] = {}
                        tmpresults[taskStr]['startTime'] = startTime
                        
                
                if endTaskRE.search(line):
                    taskStr = endTaskRE.search(line).group('taskname')
                    endTimeStr = dateFmtRE.search(line).group('timedate')

                    endTime = datetime.strptime(endTimeStr, '%Y-%m-%d %H:%M:%S')

                    # if mpi find max time.
                    if mpiRE.search(line):
                        if taskStr in mpiresults.keys():
                            if 'endTime' in mpiresults[taskStr].keys():
                                newEndTime = max(mpiresults[taskStr]['endTime'],endTime)
                                mpiresults[taskStr]['endTime'] = newEndTime
                            else:
                                mpiresults[taskStr]['endTime'] = endTime
                        else:
                            print("Start time but no end time. shouldn't happen")

                    # other wise take the difference and save.
                    else:
                        tmpresults[taskStr]['endTime'] = endTime

                        timeDiff = tmpresults[taskStr]['endTime'] - tmpresults[taskStr]['startTime']
                        timeDiff = timeDiff.total_seconds()

                        if 'casatasks' in results.keys():
                            results['casatasks'] = timeDiff + results['casatasks']
                        else:
                            results['casatasks'] = timeDiff

                        if taskStr in results.keys():
                            results[taskStr] = timeDiff + results[taskStr]
                        else:
                            results[taskStr] = timeDiff
                        
                        # clear tmp results.
                        tmpresults = {}
                    
            else: 
                # process tasks with info line
                if taskTimeRE.search(line):

                    (taskStr,startTimeStr, endTimeStr) = taskTimeRE.search(line).groups()

                    startTime = datetime.strptime(startTimeStr,  '%Y-%m-%d %H:%M:%S.%f')
                    endTime = datetime.strptime(endTimeStr,  '%Y-%m-%d %H:%M:%S.%f')

                    # separate out the pipeline parallelized imaging case.
                    if mpiRE.search(line):
                
                        if (taskStr in mpiresults.keys()):
                            # the start time should be the earliest time
                            newStartTime = min(mpiresults[taskStr]['startTime'],startTime)
                            mpiresults[taskStr]['startTime'] = newStartTime

                            # the end time should be the latest time
                            newEndTime = max(mpiresults[taskStr]['endTime'],endTime)
                            mpiresults[taskStr]['endTime'] = newEndTime

                        else:
                            mpiresults[taskStr] = {}
                            mpiresults[taskStr]['startTime'] = startTime
                            mpiresults[taskStr]['endTime'] = endTime

                    # non-pipeline parallelized
                    else:

                        timeDiff = endTime - startTime
                        timeDiff = timeDiff.total_seconds()     
            
                        # count up time spent on casatasks
                        if 'casatasks' in results.keys():
                            results['casatasks'] = timeDiff + results['casatasks']
                        else:
                            results['casatasks'] = timeDiff

                        # count up time spent on individual casa tasks
                        if taskStr in results.keys():
                            results[taskStr] = timeDiff + results[taskStr]
                        else:
                            results[taskStr] = timeDiff

        # is it a tool?
        if toolTimeRE.search(line):
            
            toolTime = float(toolTimeRE.search(line).group('tooltime'))
            toolName = toolTimeRE.search(line).group('toolname')

            # unify tool names between 5.6.1 and 6.x series.
            toolName = toolName.replace('casatools.','')

            # count up all time spent on casa tool calls
            if 'casatools' in results.keys():
                results['casatools'] = toolTime + results['casatools']
            else:
                results['casatools'] = toolTime

            # count up time spent on particular casa tool calls
            if toolName in results.keys():
                results[toolName] = toolTime + results[toolName]
            else:
                results[toolName] = toolTime
    
        
    # put any remaining mpi results in library.
    for mykey in mpiresults.keys():
        timeDiff = mpiresults[mykey]['endTime'] - mpiresults[mykey]['startTime']
        timeDiff = timeDiff.total_seconds()        

        if mykey+'_mpi' in results.keys():
            results[mykey+'_mpi'] = results[mykey+'_mpi'] + timeDiff

        else:
            results[mykey+'_mpi'] = timeDiff

        # add to total
        if mykey in results.keys():
            results[mykey] = results[mykey] + timeDiff
        else:
            results[mykey] = timeDiff

    # calculate total time spent on pipeline
    if ('pipeEndTime' in results.keys()) and ('pipeStartTime' in results.keys()):
        results['pipetime'] = (results['pipeEndTime'] - results['pipeStartTime']).total_seconds()
    else:
        print("Mous is malformed setting results to empty.")
        results = {} # set results to empty to indicate malformed mous

    # close input log
    filein.close()

    # return results.
    return results
                                                        

def parse_all_pipe_casalogs(logdir,n=-1):
    '''
    Purpose: parse all weblogs in directory


    TO DO: 
    -- add a parameter to look for a particular recipe

    Date        Programmer      Description of changes
    ----------------------------------------------------------------------
    1/17/2023   A.A. Kepley     Original Code
    '''

    import glob
    from large_cubes import under_to_slash

    allresults = {}
    
    if os.path.exists(logdir):
    
        loglist = glob.glob(os.path.join(logdir,"member.*.hifa_calimage*weblog.tgz","casa*.log*"))[0:n]

        for mylog in loglist:

            name = mylog.split('/')[-2]
            mous = name.split('.')[1]
            mous = under_to_slash(mous)

            try:
                print("processing casa log for mous "+mous)
                results = parse_pipe_casalog(mylog)
                allresults[mous] = results

            except:
                print('bad things have happened: '+ mous)
            

    return allresults


def plot_cal_img_time(mytab,plot_title='Cycle'):
    '''
    Purpose: Plot fraction of time spent on in calibration and imaging portions
    of the pipeline

    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/23/2023   A.A. Kepley     Original Code'
    '''

    # avoid divide by zero -- there has to be cleaner way to do this
    mymask = ~mytab['pl_totaltime'].mask

    frac_cal = mytab['pl_caltime'][mymask]/mytab['pl_totaltime'][mymask]
    frac_imgtime = mytab['pl_imgtime'][mymask]/mytab['pl_totaltime'][mymask]
    frac_cubetime = mytab['pl_cubetime'][mymask]/mytab['pl_totaltime'][mymask]
    frac_aggtime = mytab['pl_aggtime'][mymask]/mytab['pl_totaltime'][mymask]
    frac_fctime = mytab['pl_fctime'][mymask]/mytab['pl_totaltime'][mymask]

    mylabels = ['Calibration','Imaging', 'Cubes',' Agg Cont','Findcont']

    mydata = [frac_cal,frac_imgtime,frac_cubetime,frac_aggtime,frac_fctime]

    fig, ax = plt.subplots(1,1,figsize=(8,6))

    parts = ax.violinplot(mydata,showmedians=True)

    ax.set_xticks(np.arange(1,len(mylabels)+1),labels=mylabels)
    ax.set_title(plot_title)


def plot_casa_time(mytab, plot_title='Cycle 7'):
    '''
    Purpose: Plot fraction of time spent on CASA in pipeline runs

    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/23/2023   A.A. Kepley     Original Code
    '''


    
    frac_casa = (mytab['casatasks'] + mytab['casatools'])/mytab['pipetime']
    frac_tasks = (mytab['casatasks'] / mytab['pipetime'])
    frac_tools = (mytab['casatools'] /mytab['pipetime'])
    
    mylabels = ['CASA', 'Tasks', 'Tools']
    
    fig, ax = plt.subplots(1,1,figsize=(8,6))

    parts = ax.violinplot([frac_casa,frac_tasks,frac_tools], showmedians=True)

    ## Can use parts to set colors
    
    ax.set_xticks(np.arange(1,len(mylabels)+1),labels=mylabels)
    ax.set_title(plot_title)
    


def plot_casa_task_time(mytab, plot_title='Cycle 7'):
    '''
    Purpose: Plot fraction of time spent on different CASA tasks

    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/23/2023   A.A. Kepley     Original Code
    '''

    mycols_tasks = ['importasdm','flagdata','listobs','plotms','clearstat','flagcmd','gencal','plotbandpass','wvrgcal','gaincal','bandpass','setjy','flagmanager','applycal','fluxscale','tclean','exportfits','mstransform','imhead','immoments','imstat','imsubimage','makemask','immath','uvcontfit','visstat']


    mydata = []
    for mycol in mycols_tasks:
        mydata.append(mytab[mycol]/mytab['pipetime'])

        
    fig, ax = plt.subplots(1,1,figsize=(12,6))
    parts = ax.violinplot(mydata,showmedians=True, widths=0.9)
    
    ax.set_xticks(np.arange(1,len(mycols_tasks)+1),labels=mycols_tasks,rotation=90)

    ax.set_title(plot_title)
    
    
def plot_casa_tool_time(mytab, plot_title='Cycle 7'):
    '''
    Purpose: Plot fraction of time spent on different CASA tasks

    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/23/2023   A.A. Kepley     Original Code
    '''

    mycols_tasks = ['imager.selectvis','imager.advise','imager.apparentsens', 'ia.getprofile']


    mydata = []
    for mycol in mycols_tasks:
        mydata.append(mytab[mycol]/mytab['pipetime'])

        
    fig, ax = plt.subplots(1,1,figsize=(8,6))
    parts = ax.violinplot(mydata,showmedians=True, widths=0.5)
    
    ax.set_xticks(np.arange(1,len(mycols_tasks)+1),labels=mycols_tasks,rotation=90)

    ax.set_title(plot_title)
    



