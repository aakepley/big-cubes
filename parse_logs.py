import os
import sys
import numpy as np
import matplotlib.pyplot as plt
from astropy.table import Table
import ipdb



def parse_pipe_casalog(logfile):

    '''
    Purpose: parse one casa log generated by the pipeline

    Notes:

    If I really wanted to get fancy, I could do the stats per stage.
         -- The pipeline marks each stage with the message: "Starting execution for stage 27", etc.
                so I can at least break at stage boundaries.
         -- On the next line they have:    Equivalent CASA call: hif_makeimages(pipelinemode="automatic").
                With this information I could even name the stages.

    So casa will spit out times of the format 2019-12-05 24:00:00,
    which python really hates. This isn't a common issue, so I think
    I'm going to ignore? 

    Potential solution:
    -- split on space.
    -- if 2nd half is 24:00:00
    --- then change to 23:59:00
    -- join string
    -- do datetime parsing.
    -- But it would require a bunch of changes to the code and I'm short on time. Could make function.
    
    -- I could also just go through and manually fix the logs. Not great.


    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/17/2023   A.A. Kepley     Original Code

    '''
    import gzip
    from datetime import datetime
    import re
    
    casaVersionRE = re.compile(r"CASA Version (?P<casaversion>.*)")

    recipeRE = re.compile(r"Procedure name: (?P<recipename>\w+)")

    pipelineStartRE = re.compile(r"Starting procedure execution")
    pipelineEndRE = re.compile(r"Saving final weblog")

    # key off of task time report right before End Task message in CASA
    ## But this doesn't work in CASA 5.6.1
    taskTimeRE = re.compile(r"Task (?P<taskname>\w+) complete. Start time: (?P<startTime>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{6}) End time: (?P<endTime>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{6})" )

    # these will work for 5.6.1
    beginTaskRE = re.compile(r'Begin Task: (?P<taskname>\w+)')
    endTaskRE = re.compile(r'End Task: (?P<taskname>\w+)')

    # MPI server
    mpiRE = re.compile(r"MPIServer-")

    # plotms Tier0
    plotmsTier0RE = re.compile(r"Compressed \d+ plotms jobs to \d+ jobs")
    
    # tclean Tier0
    tcleanTier0RE = re.compile(r"setupCluster, Setting up \d+ engines")
    #tcleanTier0RE = re.compile(r"Executing Tier0PipelineTask") # will this work for both??NO
    tcleanTier0_casa56RE = re.compile(r'Starting execution for stage 19')
    # uvcontfit
    uvcontfitStartRE = re.compile(r"Executing uvcontfit")
    uvcontfitEndRE = re.compile(r"Executing command \.\.\.hif_uvcontsub")
    
    # tool time call
    toolTimeRE = re.compile(r"(?P<toolname>\S+)\(.*?\) CASA tool call took (?P<tooltime>.*?)s")

    # ia.getprofile in fincont
    iagetprofileStartRE = re.compile(r"Running ia.getprofile")
    
    # date format
    dateFmtRE = re.compile(r"(?P<timedate>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})")

    # open file
    if logfile.endswith('.gz'):
        filein = gzip.open(logfile,mode='rb')
    else:
        filein = open(logfile, 'rb')

    # initialize values
    results = {}
    startTime = 0
    endTime = 0
    mpiresults = {}
    tmpresults = {}

    # parse log
    for line in filein:

        line = line.decode('utf-8')

        ## casa version
        if 'casaversion' not in results.keys():
            if casaVersionRE.search(line):
                results['casaversion'] = casaVersionRE.search(line).group('casaversion')
                results['casaversion'] = results['casaversion'].replace('PIPELINE','').strip()


        ## recipe
        if 'recipe' not in results.keys():
            if recipeRE.search(line):
                results['recipe'] = recipeRE.search(line).group('recipename')

        ## Pipeline start  -- only take first value
        if 'pipeStartTime' not in results.keys():
            if pipelineStartRE.search(line):
                pipeStartTimeStr = dateFmtRE.search(line).group('timedate')
                results['pipeStartTime'] = datetime.strptime(pipeStartTimeStr,'%Y-%m-%d %H:%M:%S')

        ## Pipeline end
        if pipelineEndRE.search(line):
            pipeEndTimeStr = dateFmtRE.search(line).group('timedate')
          
            results['pipeEndTime'] = datetime.strptime(pipeEndTimeStr,'%Y-%m-%d %H:%M:%S')      


        
        ## figure out if we are starting tier0 parallelization
        if (plotmsTier0RE.search(line) or tcleanTier0RE.search(line) or tcleanTier0_casa56RE.search(line)):

            # save results so far
            for mykey in mpiresults.keys():
                timeDiff = mpiresults[mykey]['endTime'] - mpiresults[mykey]['startTime']
                timeDiff = timeDiff.total_seconds()        

                # indicate if mpi
                if mykey+'_mpi' in results.keys():
                    results[mykey+'_mpi'] = results[mykey+'_mpi'] + timeDiff
                else:
                    results[mykey+'_mpi'] = timeDiff
                    
                # add to total
                if mykey in results.keys():
                    results[mykey] = results[mykey] + timeDiff
                else:
                    results[mykey] = timeDiff
            
            # reset mpiresults
            mpiresults = {}


        ## look for uvcontfit
        if uvcontfitStartRE.search(line):
            uvcontfitStartTimeStr = dateFmtRE.search(line).group('timedate')
            uvcontfitStartTime = datetime.strptime(uvcontfitStartTimeStr,'%Y-%m-%d %H:%M:%S')

        if uvcontfitEndRE.search(line):
            uvcontfitEndTimeStr = dateFmtRE.search(line).group('timedate')
            uvcontfitEndTime = datetime.strptime(uvcontfitEndTimeStr,'%Y-%m-%d %H:%M:%S')

            timeDiff = (uvcontfitEndTime - uvcontfitStartTime).total_seconds()

            # add to uvcontfit total
            if 'uvcontfit' in results.keys():
                results['uvcontfit'] = timeDiff  + results['uvcontfit']
            else:
                results['uvcontfit'] = timeDiff
        
            # add to casa tasks total
            if 'casatasks' in results.keys():
                results['casatasks'] = results['casatasks'] + timeDiff
            else:
                results['casatasks' ] = timeDiff
            
                
        ## look for iagetprofile
        if iagetprofileStartRE.search(line):
            iagetprofileStartTimeStr = dateFmtRE.search(line).group('timedate')
            iagetprofileStartTime = datetime.strptime(iagetprofileStartTimeStr,'%Y-%m-%d %H:%M:%S')
            
            # read in intermediate line
            line = filein.readline().decode('utf-8')

            # read in third line that gives end.
            line = filein.readline().decode('utf-8')
            iagetprofileEndTimeStr = dateFmtRE.search(line).group('timedate')
            iagetprofileEndTime = datetime.strptime(iagetprofileEndTimeStr,'%Y-%m-%d %H:%M:%S')

            timeDiff =  (iagetprofileEndTime - iagetprofileStartTime).total_seconds()

            # add to ia.getprofile in results
            if 'ia.getprofile' in results.keys():
                results['ia.getprofile'] = timeDiff + results['ia.getprofile']
            else:
                results['ia.getprofile'] = timeDiff

            # add to total for casa tools
            if 'casatools' in results.keys():
                results['casatools'] = timeDiff + results['casatools']
            else:
                results['casatools'] = timeDiff
            
        # process tasks        
        if 'casaversion' in results.keys():
            # process tasks without info line
            if results['casaversion'] == '5.6.1-8':            
                if beginTaskRE.search(line):
                    taskStr = beginTaskRE.search(line).group('taskname')
                    startTimeStr = dateFmtRE.search(line).group('timedate')

                    startTime = datetime.strptime(startTimeStr, '%Y-%m-%d %H:%M:%S')
                    
                    if mpiRE.search(line):
                        if taskStr in mpiresults.keys():
                            newStartTime = min(mpiresults[taskStr]['startTime'],startTime)
                            mpiresults[taskStr]['startTime'] = newStartTime
                        else:
                            mpiresults[taskStr] = {}
                            mpiresults[taskStr]['startTime'] = startTime
                    else:
                        tmpresults[taskStr] = {}
                        tmpresults[taskStr]['startTime'] = startTime
                        
                
                if endTaskRE.search(line):
                    taskStr = endTaskRE.search(line).group('taskname')
                    endTimeStr = dateFmtRE.search(line).group('timedate')

                    endTime = datetime.strptime(endTimeStr, '%Y-%m-%d %H:%M:%S')

                    # if mpi find max time.
                    if mpiRE.search(line):
                        if taskStr in mpiresults.keys():
                            if 'endTime' in mpiresults[taskStr].keys():
                                newEndTime = max(mpiresults[taskStr]['endTime'],endTime)
                                mpiresults[taskStr]['endTime'] = newEndTime
                            else:
                                mpiresults[taskStr]['endTime'] = endTime
                        else:
                            print("Start time but no end time. shouldn't happen")

                    # other wise take the difference and save.
                    else:
                        tmpresults[taskStr]['endTime'] = endTime

                        timeDiff = tmpresults[taskStr]['endTime'] - tmpresults[taskStr]['startTime']
                        timeDiff = timeDiff.total_seconds()

                        if 'casatasks' in results.keys():
                            results['casatasks'] = timeDiff + results['casatasks']
                        else:
                            results['casatasks'] = timeDiff

                        if taskStr in results.keys():
                            results[taskStr] = timeDiff + results[taskStr]
                        else:
                            results[taskStr] = timeDiff
                        
                        # clear tmp results.
                        tmpresults = {}
                    
            else: 
                # process tasks with info line
                if taskTimeRE.search(line):

                    (taskStr,startTimeStr, endTimeStr) = taskTimeRE.search(line).groups()

                    startTime = datetime.strptime(startTimeStr,  '%Y-%m-%d %H:%M:%S.%f')
                    endTime = datetime.strptime(endTimeStr,  '%Y-%m-%d %H:%M:%S.%f')

                    # separate out the pipeline parallelized imaging case.
                    if mpiRE.search(line):
                
                        if (taskStr in mpiresults.keys()):
                            # the start time should be the earliest time
                            newStartTime = min(mpiresults[taskStr]['startTime'],startTime)
                            mpiresults[taskStr]['startTime'] = newStartTime

                            # the end time should be the latest time
                            newEndTime = max(mpiresults[taskStr]['endTime'],endTime)
                            mpiresults[taskStr]['endTime'] = newEndTime

                        else:
                            mpiresults[taskStr] = {}
                            mpiresults[taskStr]['startTime'] = startTime
                            mpiresults[taskStr]['endTime'] = endTime

                    # non-pipeline parallelized
                    else:

                        timeDiff = endTime - startTime
                        timeDiff = timeDiff.total_seconds()     
            
                        # count up time spent on casatasks
                        if 'casatasks' in results.keys():
                            results['casatasks'] = timeDiff + results['casatasks']
                        else:
                            results['casatasks'] = timeDiff

                        # count up time spent on individual casa tasks
                        if taskStr in results.keys():
                            results[taskStr] = timeDiff + results[taskStr]
                        else:
                            results[taskStr] = timeDiff

        # is it a tool?
        if toolTimeRE.search(line):
            
            toolTime = float(toolTimeRE.search(line).group('tooltime'))
            toolName = toolTimeRE.search(line).group('toolname')

            # unify tool names between 5.6.1 and 6.x series.
            toolName = toolName.replace('casatools.','')

            # count up all time spent on casa tool calls
            if 'casatools' in results.keys():
                results['casatools'] = toolTime + results['casatools']
            else:
                results['casatools'] = toolTime

            # count up time spent on particular casa tool calls
            if toolName in results.keys():
                results[toolName] = toolTime + results[toolName]
            else:
                results[toolName] = toolTime
    
        
    # put any remaining mpi results in library.
    for mykey in mpiresults.keys():
        timeDiff = mpiresults[mykey]['endTime'] - mpiresults[mykey]['startTime']
        timeDiff = timeDiff.total_seconds()        

        if mykey+'_mpi' in results.keys():
            results[mykey+'_mpi'] = results[mykey+'_mpi'] + timeDiff

        else:
            results[mykey+'_mpi'] = timeDiff

        # add to total
        if mykey in results.keys():
            results[mykey] = results[mykey] + timeDiff
        else:
            results[mykey] = timeDiff

    # calculate total time spent on pipeline
    if ('pipeEndTime' in results.keys()) and ('pipeStartTime' in results.keys()):
        results['pipetime'] = (results['pipeEndTime'] - results['pipeStartTime']).total_seconds()
    else:
        print("Mous is malformed setting results to empty.")
        results = {} # set results to empty to indicate malformed mous

    # close input log
    filein.close()

    # return results.
    return results
                                                        

def parse_all_pipe_casalogs(logdir,n=-1,recipe='hifa_calimage*',
                            errfile='mous_err.txt'):
    '''
    Purpose: parse all weblogs in directory


    TO DO: 
    -- add a parameter to look for a particular recipe

    Date        Programmer      Description of changes
    ----------------------------------------------------------------------
    1/17/2023   A.A. Kepley     Original Code
    '''

    import glob
    from large_cubes import under_to_slash

    ferr = open(errfile,'w')

    allresults = {}
    
    if os.path.exists(logdir):
    
        loglist = glob.glob(os.path.join(logdir,"member.*."+recipe+".weblog.tgz","casa*.log*"))[0:n]

        for mylog in loglist:

            name = mylog.split('/')[-2]
            mous = name.split('.')[1]
            mous = under_to_slash(mous)

            try:
                print("processing casa log for mous "+mous)
                results = parse_pipe_casalog(mylog)
                allresults[mous] = results

            except:
                print('*** Bad things have happened here: '+ mous)
                ferr.write(mous+'\n')

    ferr.close()

    return allresults

def plot_timedist(mytab,plot_title='Test',figname=None):
    '''
    Purpose: plot distribution of pipeline run times

    Date        Programmer      Description of Changes
    ---------------------------------------------------
    1/30/2023   A.A. Kepely     Original Code
    
    '''

    hours_per_day = 24.0 #h
    hours_per_week = hours_per_day * 7.0
    hours_per_month = hours_per_day * 30.0
    hours_per_year = hours_per_day * 365.0

    mybins = 500
    
    plt.hist(np.log10(mytab['pl_totaltime']),
             bins=mybins,
             cumulative=-1, histtype='step',
             log=True,
             density=True,
             label='Total PL time')
    plt.hist(np.log10(mytab['pl_caltime']),cumulative=-1, histtype='step',
             bins=mybins,
             log=True,
             density=True,
             label='Total PL calibration time')
    plt.hist(np.log10(mytab['pl_imgtime']),cumulative=-1, histtype='step',
             bins=mybins,
             log=True,
             density=True,
             label='Total PL image time')

    plt.axvline(np.log10(hours_per_week),color='black',linestyle=':')
    plt.axvline(np.log10(hours_per_month),color='black')

    plt.text(np.log10(hours_per_week)+0.05,0.1,'1 week',rotation=90)
    plt.text(np.log10(hours_per_month)+0.05,0.1,'1 month',rotation=90)


    #plt.axhline(0.5,color='gray',linestyle='--')
    

    plt.title(plot_title)
    plt.legend(loc='lower left')

    plt.xlabel('Log10(Duration in Hours)')
    plt.ylabel('Fraction of Longer Durations')

    if figname:
        plt.savefig(figname)


def plot_imgtime_breakdown(mytab, plot_title='Test',figname=None):
    '''
    Purpose: plot breakdown between cube imaging, agg cont,
    findcont

    Date        Programmer      Description of Changes
    ---------------------------------------------------
    1/30/2023   A.A. Kepley     Original Code

    '''

    hours_per_day = 24.0
    hours_per_week = hours_per_day * 7.0
    hours_per_month = hours_per_day * 30.0
    hours_per_year = hours_per_day * 365.0

    mybins = 500
    

    plt.hist(np.log10(mytab['pl_imgtime']),cumulative=-1, histtype='step',
             bins=mybins,
             log=True,
             density=True,
             label='Total PL image time',
             color='green')
    
    plt.hist(np.log10(mytab['pl_cubetime']),cumulative=-1, histtype='step',
             bins=mybins,
             log=True,
             density=True,
             label='Cube image time',
             color='orange')

    plt.hist(np.log10(mytab['pl_fctime']),cumulative=-1, histtype='step',
             bins=mybins,
             log=True,
             density=True,
             label='Findcont time')


    plt.hist(np.log10(mytab['pl_aggtime']),cumulative=-1, histtype='step',
             bins=mybins,
             log=True,
             density=True,
             label='aggcont time')

    plt.axvline(np.log10(hours_per_week),color='black',linestyle=':')
    plt.axvline(np.log10(hours_per_month),color='black')

    plt.text(np.log10(hours_per_week)+0.05,0.1,'1 week',rotation=90)
    plt.text(np.log10(hours_per_month)+0.05,0.1,'1 month',rotation=90)


    #plt.axhline(0.5,color='gray',linestyle='--')
    

    plt.title(plot_title)
    plt.legend(loc='lower left')

    plt.xlabel('Log10(Duration in Hours)')
    plt.ylabel('Fraction of Longer Durations')

    if figname:
        plt.savefig(figname)

    pass

        
def plot_caltime_estimate():
    '''
    Purpose: plot estimate for calibration time for PL

    Date        Programmer      Description of Changes
    ---------------------------------------------------

    
    
    '''

    pass

def plot_imgtime_estimate():
    '''
    '''

    pass

def plot_tottime_estimate():
    '''
    '''

    pass
    
def plot_cal_img_time(mytab,plot_title='Cycle'):
    '''
    Purpose: Plot fraction of time spent on in calibration and imaging portions
    of the pipeline

    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/23/2023   A.A. Kepley     Original Code
    '''

    idx = (mytab['procedure'] == 'hifa_caliamge') | (mytab['procedure'] == 'hifa_calimage_renorm')
    
    frac_cal = mytab['pl_caltime'][idx]/mytab['pl_totaltime'][idx]
    frac_imgtime = mytab['pl_imgtime'][idx]/mytab['pl_totaltime'][idx]
    frac_cubetime = mytab['pl_cubetime'][idx]/mytab['pl_totaltime'][idx]
    frac_aggtime = mytab['pl_aggtime'][idx]/mytab['pl_totaltime'][idx]
    frac_fctime = mytab['pl_fctime'][idx]/mytab['pl_totaltime'][idx]

    mylabels = ['Calibration','Imaging', 'Cubes',' Agg Cont','Findcont']

    mydata = [frac_cal,frac_imgtime,frac_cubetime,frac_aggtime,frac_fctime]

    fig, ax = plt.subplots(1,1,figsize=(8,6))

    parts = ax.violinplot(mydata,showmedians=True)

    ax.set_xticks(np.arange(1,len(mylabels)+1),labels=mylabels)
    ax.set_title(plot_title)


def plot_casa_time(mytab, plot_title='Cycle 7', figname=None):
    '''
    Purpose: Plot fraction of time spent on CASA in pipeline runs

    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/23/2023   A.A. Kepley     Original Code
    '''


    
    frac_casa = (mytab['casatasks'] + mytab['casatools'])/mytab['pipetime']
    frac_tasks = (mytab['casatasks'] / mytab['pipetime'])
                  
    frac_tools = (mytab['casatools'] /mytab['pipetime'])
    
    mylabels = ['CASA', 'Tasks', 'Tools']
    
    fig, ax = plt.subplots(1,1,figsize=(8,6))

    parts = ax.violinplot([frac_casa,frac_tasks,frac_tools], showmedians=True)

    ## Can use parts to set colors
    
    ax.set_xticks(np.arange(1,len(mylabels)+1),labels=mylabels)
    ax.set_title(plot_title)

    ax.set_ylabel('Fraction of pipeline run time')
    
    if figname:
        plt.savefig(figname)
    


def plot_casa_task_time(mytab, plot_title='Cycle 7', figname=None):
    '''
    Purpose: Plot fraction of time spent on different CASA tasks

    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/23/2023   A.A. Kepley     Original Code
    '''

    mycols_tasks = ['importasdm','flagdata','listobs','plotms','clearstat','flagcmd','gencal','plotbandpass','wvrgcal','gaincal','bandpass','setjy','flagmanager','applycal','fluxscale','tclean','exportfits','mstransform','imhead','immoments','imstat','imsubimage','makemask','immath','uvcontfit','visstat']


    mydata = []
    for mycol in mycols_tasks:
        mydata.append(mytab[mycol]/mytab['pipetime'])

        
    fig, ax = plt.subplots(1,1,figsize=(12,6))
    parts = ax.violinplot(mydata,showmedians=True, widths=0.9)
    
    ax.set_xticks(np.arange(1,len(mycols_tasks)+1),labels=mycols_tasks,rotation=90)

    ax.set_title(plot_title)

    ax.set_ylabel('Fraction of pipeline run time')
    
    if figname:
        plt.savefig(figname)
    
def plot_casa_tool_time(mytab, plot_title='Cycle 7'):
    '''
    Purpose: Plot fraction of time spent on different CASA tasks

    Date        Programmer      Description of Changes
    ----------------------------------------------------------------------
    1/23/2023   A.A. Kepley     Original Code
    '''

    mycols_tasks = ['imager.selectvis','imager.advise','imager.apparentsens', 'ia.getprofile']


    mydata = []
    for mycol in mycols_tasks:
        mydata.append(mytab[mycol]/mytab['pipetime'])

        
    fig, ax = plt.subplots(1,1,figsize=(8,6))
    parts = ax.violinplot(mydata,showmedians=True, widths=0.5)
    
    ax.set_xticks(np.arange(1,len(mycols_tasks)+1),labels=mycols_tasks,rotation=90)

    ax.set_title(plot_title)
    



def convert_to_astropy(pkl_file, dump_rows=None):
    '''
    Purpose: convert casa/pl timing pickle to astropy table

    pkl: input pickle
    
    Date        Programmer      Description of Changes
    ----------------------------------------------------
    1/30/2023   A.A. Kepley     Original Code
  
    '''
    import pickle
    import pandas as pd
    from large_cubes import fix_mous_col

    pkl = pickle.load(open(pkl_file,'rb'))

    rpd = pd.DataFrame(pkl).transpose()

    # fix up data types
    mycols_float = ['importasdm','flagdata','listobs','plotms','clearstat',
                    'flagcmd','gencal','plotbandpass','wvrgcal','gaincal',
                    'bandpass','setjy','flagmanager','applycal','fluxscale',
                    'tclean','exportfits','mstransform','imhead','immoments',
                    'imstat','imsubimage','makemask','immath','uvcontfit','visstat',
                    'pipetime','casatasks','casatools','imager.selectvis','imager.advise',
                    'imager.apparentsens','ia.getprofile']
    
    mycols_dtype = {}
    for col in mycols_float:
        mycols_dtype[col]  = 'float'

    mycols = ['casaversion','recipe']
    for col in mycols:
        mycols_dtype[col] = 'str'
        
    rpd = rpd.astype(dtype=mycols_dtype)

    mytab = Table.from_pandas(rpd,index=True)
    mytab.rename_column('index','mous')
    mytab = Table(mytab,masked=True)

    for col in mytab.columns:
        if col in mycols_float:
            mytab.fill_value = np.nan

    fix_mous_col(mytab)

    if dump_rows:
        for myrow in dump_rows:
            idx = mytab['mous'] == myrow
            mytab = mytab[~idx]
            
    
    return mytab


